# camera_stream.py
# WebSocket ê¸°ë°˜ ë¼ì¸íŠ¸ë ˆì´ì‹± ë° ì‹œë¦¬ì–¼ í†µì‹  ì„œë²„ (Picamera2 -> Arduino -> ë¸Œë¼ìš°ì €)

import asyncio                          # ë¹„ë™ê¸° ì²˜ë¦¬(ì´ë²¤íŠ¸ ë£¨í”„, sleep ë“±)
import base64                           # ë°”ì´ë„ˆë¦¬ ë°ì´í„°ë¥¼ Base64ë¡œ ì¸ì½”ë”©
import cv2                              # OpenCV: ì˜ìƒ ì²˜ë¦¬
import serial                           # pyserial: ì•„ë‘ì´ë…¸ì™€ ì‹œë¦¬ì–¼ í†µì‹ 
from picamera2 import Picamera2        # Raspberry Pi ì¹´ë©”ë¼ ì œì–´ (libcamera ê¸°ë°˜)
import websockets                       # WebSocket ì„œë²„ êµ¬í˜„

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ì‹œë¦¬ì–¼ í¬íŠ¸ ì„¤ì •
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
try:
    # '/dev/ttyACM0' í¬íŠ¸ë¡œ 9600bps ì‹œë¦¬ì–¼ ì—°ê²° (ì•„ë‘ì´ë…¸ ê¸°ë³¸)
    arduino = serial.Serial('/dev/ttyACM0', 9600, timeout=1)
    print("âœ… ì•„ë‘ì´ë…¸ ì—°ê²° ì™„ë£Œ")
except serial.SerialException as e:
    # ì—°ê²° ì‹¤íŒ¨ ì‹œ ì˜ˆì™¸ ì²˜ë¦¬ í›„ arduino ê°ì²´ë¥¼ Noneìœ¼ë¡œ ì„¤ì •
    print(f"âŒ ì•„ë‘ì´ë…¸ ì—°ê²° ì‹¤íŒ¨: {e}")
    arduino = None


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ë¼ì¸ ì¤‘ì‹¬ ê²€ì¶œ í•¨ìˆ˜
# ì…ë ¥: BGR í˜•ì‹ì˜ í”„ë ˆì„ (NumPy ë°°ì—´)
# ì¶œë ¥: (ì¤‘ì‹¬ xì¢Œí‘œ, ì „ì²˜ë¦¬ëœ ë°”ì´ë„ˆë¦¬ ì˜ìƒ, ROI ì‹œì‘ yì¢Œí‘œ, ì»¨íˆ¬ì–´ ë¦¬ìŠ¤íŠ¸)
#    - ì¤‘ì‹¬ xì¢Œí‘œ: ê²€ì¶œ ì‹¤íŒ¨ ì‹œ -1 ë°˜í™˜
#    - clean: ë…¸ì´ì¦ˆ ì œê±°ëœ ë°”ì´ë„ˆë¦¬ ì˜ìƒ ë””ë²„ê·¸ìš©
#    - y0: í•˜ë‹¨ ROI ì‹œì‘ ìœ„ì¹˜(ì „ì²´ ë†’ì´ì˜ 60%)
#    - best_cnts: ê²€ì¶œëœ ì»¨íˆ¬ì–´ ë¦¬ìŠ¤íŠ¸ (ì—†ìœ¼ë©´ ë¹ˆ ë¦¬ìŠ¤íŠ¸)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def detect_line_center(frame):
    # 1) ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜ (BGR -> Gray)
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # 2) ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ ì ìš©ìœ¼ë¡œ ë°˜ì‚¬ê´‘(í•˜ì´ë¼ì´íŠ¸) ì—£ì§€ ì™„í™”
    blur = cv2.GaussianBlur(gray, (5, 5), 0)

    # 3) Otsu ì´ì§„í™”: ìë™ ì„ê³„ê°’ ì„ íƒ, ë°˜ì „ëœ ë°”ì´ë„ˆë¦¬
    #    - cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
    _, binary = cv2.threshold(
        blur, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
    )

    # 4) ëª¨í´ë¡œì§€ ì—°ì‚°ìœ¼ë¡œ ì‘ì€ ë…¸ì´ì¦ˆ ì œê±°
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
    clean = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel, iterations=1)
    clean = cv2.morphologyEx(clean, cv2.MORPH_CLOSE, kernel, iterations=1)

    # ì „ì²´ ì´ë¯¸ì§€ í¬ê¸° ì–»ê¸°
    h, w = clean.shape
    # í•˜ë‹¨ 40% ì˜ì—­ì„ ROIë¡œ ì„¤ì • (y0: ì‹œì‘ yì¢Œí‘œ)
    y0 = int(h * 0.6)
    roi = clean[y0:h, :]

    # 5) ROIì—ì„œ ì™¸ê³½ì„ (ì»¨íˆ¬ì–´) ê²€ì¶œ
    contours, _ = cv2.findContours(
        roi, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
    )
    if not contours:
        # ì»¨íˆ¬ì–´ ì—†ìœ¼ë©´ ê²€ì¶œ ì‹¤íŒ¨
        return -1, clean, y0, []

    # 6) ê°€ì¥ ë„“ì€ ì»¨íˆ¬ì–´ ì„ íƒ (ë©´ì  ê¸°ì¤€)
    cnt = max(contours, key=cv2.contourArea)
    # ë©´ì ì´ ë„ˆë¬´ ì‘ìœ¼ë©´ ë¬´ì‹œ
    if cv2.contourArea(cnt) < 500:
        return -1, clean, y0, []

    # 7) ëª¨ë©˜íŠ¸ ê³„ì‚°ìœ¼ë¡œ ì¤‘ì‹¬ì (x) ê³„ì‚°
    M = cv2.moments(cnt)
    if M["m00"] == 0:
        # ë¶„ëª¨ê°€ 0ì´ë©´ ë¬´ì‹œ
        return -1, clean, y0, []
    cx = int(M["m10"] / M["m00"] )

    # ì»¨íˆ¬ì–´ ì¢Œí‘œë¥¼ ì›ë³¸ í”„ë ˆì„ ê¸°ì¤€ìœ¼ë¡œ ì´ë™ (y0 ë§Œí¼ offset)
    cnt[:, 0, 1] += y0

    # ê²°ê³¼ ë°˜í™˜
    return cx, clean, y0, [cnt]


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# WebSocket í´ë¼ì´ì–¸íŠ¸ ìŠ¤íŠ¸ë¦¬ë° í•¸ë“¤ëŸ¬
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def stream(websocket, path=None):
    # Picamera2 ì´ˆê¸°í™” ë° ì„¤ì •
    picam2 = Picamera2()
    config = picam2.create_preview_configuration(main={"size": (640, 480)})
    picam2.configure(config)
    picam2.start()
    print("ğŸ¥ Picamera2 ì‹œì‘ë¨")

    try:
        while True:
            # 1) ì¹´ë©”ë¼ì—ì„œ í”„ë ˆì„ íšë“ (NumPy ë°°ì—´, BGR)
            frame = picam2.capture_array()
            # 2) RGBë¡œ ë³€í™˜ (ìë°”ìŠ¤í¬ë¦½íŠ¸ Canvas í‘œì‹œìš©)
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            h, w = frame.shape[:2]

            # 3) ë¼ì¸ ì¤‘ì‹¬ ê²€ì¶œ
            cx, clean, y0, best_cnts = detect_line_center(frame)
            print(f"ğŸ“ ë¼ì¸ ì¤‘ì‹¬: {cx}")

            # 4) ROI ì˜ì—­ ì‹œê°í™” (ì´ˆë¡ ì‚¬ê°í˜•)
            cv2.rectangle(frame, (0, y0), (w - 1, h - 1), (0, 255, 0), 2)

            # 5) ì›í•˜ëŠ” ê²½ìš° ë°”ì´ë„ˆë¦¬ clean ì˜ìƒì„ ë””ë²„ê¹…ìš©ìœ¼ë¡œ í”„ë ˆì„ì— ë®ì–´ì“°ê¸°
            # frame[0:clean.shape[0], 0:clean.shape[1], 2] = clean

            # 6) ê²€ì¶œëœ ì»¨íˆ¬ì–´ëŠ” ë¹¨ê°„ ìœ¤ê³½ìœ¼ë¡œ í‘œì‹œ
            for cnt in best_cnts:
                cv2.drawContours(frame, [cnt], -1, (0, 0, 255), 2)

            # 7) Pi -> Arduino: ì¤‘ì‹¬ xì¢Œí‘œ ì „ì†¡ (ê²€ì¶œ ì„±ê³µ ì‹œ)
            if arduino and cx != -1:
                arduino.write(f"{cx}\n".encode())

            # 8) Arduino -> Pi ì‘ë‹µ ìˆ˜ì‹  (ì˜µì…˜: ë™ì‘ í™•ì¸ìš©)
            if arduino and arduino.in_waiting:
                try:
                    resp = arduino.readline().decode().strip()
                    if resp:
                        print(f"ğŸ” Arduino ì‘ë‹µ: {resp}")
                except Exception as e:
                    print(f"âš ï¸ ì‘ë‹µ íŒŒì‹± ì˜¤ë¥˜: {e}")

            # 9) í”„ë ˆì„ì„ JPEGë¡œ ì¸ì½”ë”© í›„ Base64ë¡œ ë³€í™˜
            ret, jpg = cv2.imencode('.jpg', frame)
            if ret:
                data = base64.b64encode(jpg.tobytes()).decode('utf-8')
                # WebSocketì„ í†µí•´ í´ë¼ì´ì–¸íŠ¸ì— ì „ì†¡
                await websocket.send(data)

            # 10) ì•½ 20fps (50ms) ëŒ€ê¸°
            await asyncio.sleep(0.05)

    except websockets.exceptions.ConnectionClosed:
        # í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²° ì¢…ë£Œí•˜ë©´ ë£¨í”„ íƒˆì¶œ
        print("ğŸ”Œ í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¢…ë£Œ")
    finally:
        # ì¢…ë£Œ ì‹œ Picameraì™€ ì‹œë¦¬ì–¼ í¬íŠ¸ ì •ë¦¬
        picam2.close()
        if arduino:
            arduino.close()
        print("ğŸ“· ì¢…ë£Œ")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ë©”ì¸ í•¨ìˆ˜: WebSocket ì„œë²„ ì‹œì‘
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def main():
    # 0.0.0.0:8765 í¬íŠ¸ì—ì„œ WebSocket ì„œë²„ ëŒ€ê¸°
    await websockets.serve(stream, '0.0.0.0', 8765)
    print("âœ… WebSocket ì„œë²„ ì‹œì‘: ws://<RaspberryPi_IP>:8765")
    # ë¬´í•œ ëŒ€ê¸°
    await asyncio.Future()


if __name__ == '__main__':
    # asyncio ì´ë²¤íŠ¸ ë£¨í”„ë¥¼ ì‚¬ìš©í•´ main() ì‹¤í–‰
    asyncio.run(main())
